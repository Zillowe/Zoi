---
title: Creating Packages
description: A complete guide on how to create a package for Zoi.
---

This guide provides a comprehensive overview of how to create packages for Zoi. The core of Zoi packaging is the `.pkg.lua` file, a Lua script that gives you immense power and flexibility to define how your software is built, packaged, and installed.

## The `.pkg.lua` File

At its heart, a Zoi package is defined by a `.pkg.lua` file. This file uses a series of global functions and variables provided by the Zoi runtime to declare metadata, handle dependencies, and script the entire build and installation process.

### Core Functions

These are the main functions you'll use to structure your package definition.

- `metadata{...}`: **(Required)** This function defines all the essential information about your package. It takes a Lua table as an argument. See the "Metadata" section below for details.
- `dependencies{...}`: Defines runtime or build-time dependencies. This can be a simple list of packages or a more complex structure with optional and selectable dependencies. For a detailed guide, see the [Dependencies & Supported Package Managers](/docs/zds/zoi/dependencies) page.
- `prepare()`: This function is executed first during the build process. It's used for fetching sources, extracting archives, and setting up the build environment inside a temporary directory.
- `package()`: This function is executed after `prepare()`. Its job is to take the prepared sources and copy the final files into the staging area, from which the package archive will be created.
- `verify()`: Executed after `package()`, this function can be used to run checks to ensure the package is safe and correct, such as verifying checksums and PGP signatures of downloaded files. If it returns `false`, the build will be halted.
- `uninstall()`: This function is reserved for custom uninstallation logic. It can be used to run commands to clean up files or configurations created by the package outside of the main Zoi store.

### The Lua Environment

When Zoi executes your `.pkg.lua` script, it provides a set of global variables and helper functions to assist with the packaging process.

#### Global Variables

- `SYSTEM`: A table containing information about the user's system (`SYSTEM.OS`, `SYSTEM.ARCH`, `SYSTEM.DISTRO`, `SYSTEM.MANAGER`).
- `ZOI`: A table with Zoi-specific information, like the running version (`ZOI.VERSION`) and installation paths (`ZOI.PATH.user`, `ZOI.PATH.system`).
- `PKG`: A table containing the metadata you defined in the `metadata{}` block. This is useful for dynamically accessing version numbers, names, etc.
- `BUILD_DIR`: The absolute path to the temporary directory where the build takes place. Use this as the root for all your build operations.
- `STAGING_DIR`: The absolute path to the directory where final package contents should be placed.
- `BUILD_TYPE`: A string indicating the current build type (e.g. `"source"` or `"pre-compiled"`), passed via the `zoi package build --type` flag.

#### Helper Functions

- `cmd(command)`: Executes a shell command.
- `zcp(source, destination)`: Copies files or directories into the staging area. This is the primary function used in the `package()` step.
- `zrm(path)`: A function for the `uninstall()` step to remove files or directories.
- `verifyHash(file_path, "algo-hash")`: Verifies the checksum of a file.
- `verifySignature(file_path, sig_path, key_name)`: Verifies a PGP signature.
- `addPgpKey(url_or_path, name)`: Adds a PGP key to Zoi's keyring.
- `UTILS.EXTRACT(url_or_path, out_dir)`: Downloads (if URL) and extracts an archive.
- `UTILS.FETCH.url(url)`: Fetches the content of a URL as a string.
- `UTILS.FETCH.GITHUB.LATEST.release{...}`: Fetches the latest release tag from a GitHub repository.
- `UTILS.FIND.file(dir, name)`: Finds a file within the build directory.
- `UTILS.PARSE.checksumFile(content, file_name)`: Parses a checksum from a checksums file.

#### Staging Destinations for `zcp`

The `destination` argument for `zcp` uses special variables to target different locations in the final installed package:

- `${pkgstore}`: The main directory for the package's files within the Zoi store. Binaries, libraries, and assets usually go here (e.g. `${pkgstore}/bin/my-cli`, `${pkgstore}/share/icons/icon.png`).
- `${createpkgdir}`: **For `app` packages only.** Files copied here are used as the template when a user runs `zoi create`.
- `${usrroot}`: Copies files to the system's root directory (`/`). **Use with extreme caution**, as this can modify system files and requires administrator privileges to install.
- `${usrhome}`: Copies files to the user's home directory (`~`).

## Package Types

You can define the type of your package in the `metadata` block using the `package_type` field.

```lua
metadata({
  name = "my-package",
  package_type = "package", -- "package", "collection", "app", or "extension"
  ...
})
```

### 1. `package` (Default)

This is the standard package type for distributing software, tools, or any set of files.

- **Goal**: Install applications, command-line tools, libraries, etc.
- **How it works**: The `package()` function stages the final files (binaries, assets) into the `${pkgstore}` directory. Upon installation, Zoi places these files in a versioned directory inside `~/.zoi/pkgs/store` and symlinks any executables listed in the `bins` metadata field into `~/.zoi/pkgs/bin`.
- **Example**: See the "Simple Pre-compiled Binary" or "Simple Source Build" examples in the [Package Examples](/docs/zds/zoi/examples) document.

### 2. `collection`

A collection is a meta-package that groups other packages together.

- **Goal**: Install a list of related packages with a single command.
- **How it works**: A collection package typically has no `prepare` or `package` steps. Its main purpose is to list other packages in its `dependencies` block. When a user installs the collection, Zoi simply installs all the listed dependencies.
- **Example**: A `rust-dev-tools` collection.

```lua
metadata({
  name = "rust-dev-tools",
  repo = "community",
  version = "1.0.0",
  description = "A collection of useful Rust development tools.",
  package_type = "collection",
})

dependencies({
  runtime = {
    required = {
      "zoi:rustup",
      "cargo:cargo-edit",
      "cargo:cargo-watch",
      "cargo:cargo-audit",
    }
  }
})
```

### 3. `app`

An `app` package is a template or boilerplate used to bootstrap new projects.

- **Goal**: Create a starter project structure for users.
- **How it works**: In the `package()` function, you copy your template files into the `${createpkgdir}` staging directory. When a user runs `zoi create <my-new-app> --source your-app-package`, Zoi builds your package and extracts the contents of `${createpkgdir}` into a new directory named `<my-new-app>`.
- **Example**: A "Hello World" web server template.

```lua
metadata({
  name = "hello-web-server",
  repo = "community",
  version = "1.0.0",
  description = "A simple Node.js web server template.",
  package_type = "app",
})

function package()
  -- These files would be created or downloaded in the prepare() step
  zcp("template/package.json", "${createpkgdir}/package.json")
  zcp("template/index.js", "${createpkgdir}/index.js")
  zcp("template/README.md", "${createpkgdir}/README.md")
end
```

### 4. `extension`

An extension is a special package type that modifies the user's Zoi configuration.

- **Goal**: Add new repositories, change the default registry, or import PGP keys.
- **How it works**: The package must contain an `extension` table within its `metadata`. This table lists the changes to be applied. When a user runs `zoi extension add your-extension-package`, Zoi reads this table and performs the specified actions.
- **Example**: An extension to add a third-party repository.

```lua
metadata({
  name = "my-cool-repo-ext",
  repo = "community",
  version = "1.0.0",
  description = "Adds the 'my-cool-repo' to Zoi.",
  package_type = "extension",
  extension = {
    type = "zoi", -- Required, currently only "zoi" is supported
    changes = {
      {
        type = "repo-add",
        add = "my-cool-repo"
      },
      {
        type = "pgp",
        name = "my-cool-repo-key",
        key = "https://example.com/key.asc" -- URL or fingerprint
      }
    }
  }
})
```

## Building and Testing Your Package

### Testing Locally

The fastest way to test your `.pkg.lua` file is to install it directly. This command will resolve dependencies and run the full installation logic without creating an intermediate package archive. It's perfect for iterating on your `prepare` and `package` functions.

```sh
zoi install /path/to/your-package.pkg.lua
```

### Building the Package Archive

Once you are confident your package works, you can build a distributable archive. This is what Zoi would download from a pre-built package registry.

```sh
zoi package build --type <build-type> /path/to/your-package.pkg.lua
```

- `--type`: Specify the build type, e.g. `source` or `pre-compiled`. This value is available in your script as the `BUILD_TYPE` global variable.

This command creates a `.pkg.tar.zst` file in the same directory as your `.pkg.lua` file.

### Installing the Built Archive

To ensure your final archive is correct, you can install it locally using the `zoi package install` command.

```sh
zoi package install /path/to/your-package-1.0.0-linux-amd64.pkg.tar.zst
```

This command unpacks the archive and runs the same installation procedure that a user would experience, providing a final end-to-end test of your package.

## Next Steps: Publishing Your Package

Once you have created and tested your package, the next step is to make it available to others. For a detailed guide on how to submit your package to the official Zoidberg repository or how to host your own, see the [Publishing Packages](/docs/zds/zoi/publishing-packages) guide.
