---
title: Creating Packages
description: A complete guide on how to create a package for Zoi.
---

This guide provides a comprehensive overview of how to create packages for Zoi. The core of Zoi packaging is the `.pkg.lua` file, a Lua script that gives you immense power and flexibility to define how your software is built, packaged, and installed.

## The `.pkg.lua` File

At its heart, a Zoi package is defined by a `.pkg.lua` file. This file uses a series of global functions and variables provided by the Zoi runtime to declare metadata, handle dependencies, and script the entire build and installation process. This imperative approach gives you fine-grained control over every step.

## Core Lifecycle Functions

These are the main functions you'll use to structure your package definition. Zoi calls them in a specific order during the build process: `prepare` -> `package` -> `verify`.

- `metadata{...}`: **(Required)** This function defines all the essential information about your package. It takes a Lua table as an argument.
- `dependencies{...}`: Defines runtime or build-time dependencies.
- `prepare()`: This function is executed first. It's used for fetching sources, extracting archives, and setting up the build environment inside a temporary directory.
- `package()`: This function is executed after `prepare()`. Its job is to take the prepared sources and copy the final files into the staging area, from which the package archive will be created.
- `verify()`: Executed after `package()`, this function can be used to run checks to ensure the package is safe and correct, such as verifying checksums and PGP signatures of downloaded files. If it returns `false`, the build will be halted.
- `uninstall()`: This function is reserved for custom uninstallation logic. It can be used to run commands to clean up files or configurations created by the package outside of the main Zoi store.

## The Lua Environment

When Zoi executes your `.pkg.lua` script, it provides a set of global variables and helper functions.

#### Global Variables

- `SYSTEM`: A table with system info (`OS`, `ARCH`, `DISTRO`, `MANAGER`).
- `ZOI`: A table with Zoi-specific info (`VERSION`, `PATH.user`, `PATH.system`).
- `PKG`: A table containing the metadata you defined in `metadata{...}`.
- `BUILD_DIR`: The absolute path to the temporary build directory.
- `STAGING_DIR`: The absolute path to the directory where final package contents should be placed.
- `BUILD_TYPE`: A string indicating the build type (e.g. `"source"`, `"pre-compiled"`), from the `zoi package build --type` flag.

#### Helper Functions

- `cmd(command)`: Executes a shell command.
- `zcp(source, destination)`: Copies files/directories into the staging area.
- `zrm(path)`: A function for the `uninstall()` step to remove files.
- `verifyHash(file_path, "algo-hash")`: Verifies a file's checksum.
- `verifySignature(file_path, sig_path, key_name)`: Verifies a PGP signature.
- `addPgpKey(url_or_path, name)`: Adds a PGP key to Zoi's keyring.
- `UTILS.EXTRACT(url_or_path, out_dir)`: Downloads and extracts an archive.
- `UTILS.FETCH.url(url)`: Fetches a URL's content as a string.
- `UTILS.FETCH.GITHUB.LATEST.release{...}`: Fetches the latest release tag from GitHub.
- `UTILS.FIND.file(dir, name)`: Finds a file within the build directory.
- `UTILS.PARSE.checksumFile(content, file_name)`: Parses a checksum from a file's content.

#### Staging Destinations for `zcp`

The `destination` for `zcp` uses special variables:

- `${pkgstore}`: The main directory for the package's files in the Zoi store (e.g. `${pkgstore}/bin/my-cli`).
- `${createpkgdir}`: For `app` packages, to be used as a template.
- `${usrroot}`: Copies files to the system's root (`/`). **Use with extreme caution.**
- `${usrhome}`: Copies files to the user's home directory (`~`).

## Packaging 'hello': A Walkthrough

Let's walk through packaging a simple "Hello, World!" program written in Zig. This example demonstrates a package that can be built from source or installed from a pre-compiled binary.

**Source files:**

- `main.zig`:

```zig
const std = @import("std");

pub fn main() !void {
    const stdout_writer = std.io.getStdOut().writer();
    try stdout_writer.print("Hello, World!\n", .{});
}
```

- `app/hello.pkg.lua`: (content below)
- `app/man.md`: A simple markdown manual.

### `app/hello.pkg.lua`

```lua
-- 1. Helper variables and functions
local repo_owner = "Zillowe"
local repo_name = "Hello"
local version = ZOI.VERSION or "3.0.0"
local git_url = "https://github.com/" .. repo_owner .. "/" .. repo_name .. ".git"
local release_base_url = "https://github.com/" .. repo_owner .. "/" .. repo_name .. "/releases/download/v" .. version

local platform_map = { macos = "darwin" }

local function get_mapped_os()
  return platform_map[SYSTEM.OS] or SYSTEM.OS
end

-- 2. Metadata
metadata({
  name = "hello",
  repo = "zillowe",
  version = version,
  description = "Hello World",
  website = "https://github.com/Zillowe/Hello",
  git = git_url,
  man = "https://raw.githubusercontent.com/Zillowe/Hello/refs/heads/main/app/man.md",
  maintainer = {
    name = "Zillowe Foundation",
    website = "https://zillowe.qzz.io",
    email = "contact@zillowe.qzz.io",
  },
  author = {
    name = "Zillowe Foundation",
    website = "https://zillowe.qzz.io",
    email = "contact@zillowe.qzz.io",
  },
  license = "Apache-2.0",
  bins = { "hello" },
  conflicts = { "hello" },
  types = { "source", "pre-compiled" },
})

-- 3. Dependencies
dependencies({
  build = {
    required = { "native:zig" },
  },
})

-- 4. Prepare Step
function prepare()
  print("Adding PGP key for verification...")
  addPgpKey("https://zillowe.pages.dev/keys/zillowe-main.asc", "zillowe-main")

  if BUILD_TYPE == "pre-compiled" then
    local ext = (SYSTEM.OS == "windows") and "zip" or "tar.xz"
    local file_name = "hello-" .. get_mapped_os() .. "-" .. SYSTEM.ARCH .. "." .. ext
    local url = release_base_url .. "/" .. file_name
    UTILS.EXTRACT(url, "precompiled")
  elseif BUILD_TYPE == "source" then
    cmd("git clone " .. PKG.git .. " " .. BUILD_DIR .. "/source")
    cmd("cd " .. BUILD_DIR .. "/source && zig build-exe main.zig -O ReleaseSmall --name hello")
  end
end

-- 5. Package Step
function package()
  local bin_name = (SYSTEM.OS == "windows") and "hello.exe" or "hello"

  if BUILD_TYPE == "pre-compiled" then
    local bin_path = UTILS.FIND.file("precompiled", bin_name)
    if bin_path then
      zcp(bin_path, "${pkgstore}/bin/" .. bin_name)
    else
      error("Could not find '" .. bin_name .. "' in pre-compiled archive.")
    end
  elseif BUILD_TYPE == "source" then
    zcp("source/" .. bin_name, "${pkgstore}/bin/" .. bin_name)
  end
end

-- 6. Verify Step
function verify()
  if BUILD_TYPE == "pre-compiled" then
    local checksum_url = release_base_url .. "/checksums-512.txt"
    local checksum_content = UTILS.FETCH.url(checksum_url)
    local ext = (SYSTEM.OS == "windows") and "zip" or "tar.xz"
    local file_name = "hello-" .. get_mapped_os() .. "-" .. SYSTEM.ARCH .. "." .. ext
    local file_path = BUILD_DIR .. "/" .. file_name
    local expected_checksum = UTILS.PARSE.checksumFile(checksum_content, file_name)

    if not expected_checksum or not verifyHash(file_path, "sha512-" .. expected_checksum) then
      print("Checksum verification failed!")
      return false
    end
    print("Checksum verified successfully.")

    print("Verifying signature...")
    local sig_url = release_base_url .. "/" .. file_name .. ".sig"
    local sig_path = BUILD_DIR .. "/" .. file_name .. ".sig"
    UTILS.FILE(sig_url, sig_path)

    if not verifySignature(file_path, sig_path, "zillowe-main") then
      print("Signature verification failed!")
      return false
    end
    print("Signature verified successfully.")
    return true
  end
  return true
end

function uninstall() end
```

**Explanation:**

1.  **Helpers:** The script starts with Lua variables and functions to dynamically construct URLs based on the version and platform.
2.  **`metadata` block:** Defines all the metadata. `types = { "source", "pre-compiled" }` declares that this package supports two build methods.
3.  **`dependencies` block:** Declares that `zig` is needed to build from source.
4.  **`prepare()`:** This function's behavior depends on the `BUILD_TYPE` global variable.
    - If `pre-compiled`, it downloads and extracts the release archive.
    - If `source`, it clones the git repository and compiles the binary using `zig`.
5.  **`package()`:** This function copies the final binary into the staging area.
    - If `pre-compiled`, it finds the binary in the extracted archive.
    - If `source`, it copies the binary from the build directory.
6.  **`verify()`:** For `pre-compiled` builds, this function downloads checksum and signature files, then uses `verifyHash()` and `verifySignature()` to ensure the download is authentic and intact. It returns `false` if verification fails, which aborts the build.

## Advanced Features & Unused Features

The `hello` package is simple. Here are some features you might need for more complex packages.

### `uninstall()` function

If your package creates files outside of its installation directory (e.g. config files in `~/.config`), you can define an `uninstall` function to clean them up.

```lua
function uninstall()
  -- zrm is a helper to remove files/directories
  zrm("~/.config/my-app")
end
```

### `updates` block

You can provide structured update information in your metadata. This is shown to the user when they run `zoi show` or `zoi update`.

```lua
metadata({
  ...
  updates = {
    {
      type = "vulnerability", -- 'vulnerability', 'change', or 'update'
      message = "Critical security vulnerability CVE-2025-12345 fixed."
    },
    {
      type = "change",
      message = "The --foo flag has been deprecated. Use --bar instead."
    }
  }
})
```

### `hooks` block

You can run scripts at different points in the package lifecycle.

```lua
metadata({
  ...
  hooks = {
    -- Can be a string or a list of strings
    post_install = "echo 'Package installed! Run my-app --help to get started.'",
    pre_remove = {
      "echo 'Backing up your config...'",
      "cp ~/.config/my-app/config.toml ~/.config/my-app/config.toml.bak"
    }
  }
})
```

Hooks can also be platform-specific. See the [Project Configuration](/docs/zds/zoi/project-config) docs for platform-specific examples which also apply here.

## Package Types

You can define the type of your package in the `metadata` block using the `package_type` field.

```lua
metadata({
  name = "my-package",
  package_type = "package", -- "package", "collection", "app", or "extension"
  ...
})
```

### 1. `package` (Default)

This is the standard package type for distributing software, tools, or any set of files.

### 2. `collection`

A collection is a meta-package that groups other packages together. Its main purpose is to list other packages in its `dependencies` block.

### 3. `app`

An `app` package is a template or boilerplate used to bootstrap new projects with `zoi create`.

### 4. `extension`

An extension is a special package type that modifies the user's Zoi configuration.

## Building and Testing Your Package

### Testing Locally

The fastest way to test your `.pkg.lua` file is to install it directly. This command will resolve dependencies and run the full installation logic without creating an intermediate package archive. It's perfect for iterating on your `prepare` and `package` functions.

```sh
zoi install /path/to/your-package.pkg.lua
```

### Build Type Selection during Installation

When `zoi install` determines that a package needs to be built from source (i.e., a pre-built binary archive is not available), it automatically selects a build type from the `types` array in your package's metadata. The selection logic is as follows:

1.  **User Override:** You can explicitly specify a build type using the `--type` flag. Zoi will use this type if it's listed in the package's `types` array.
    ```sh
    zoi install --type source my-package
    ```
2.  **Default to `pre-compiled`:** If no type is specified, Zoi will automatically look for and use the `pre-compiled` type if it is available.
3.  **Fallback to First Type:** If `pre-compiled` is not available, Zoi will fall back to using the _first_ type listed in the `types` array in your `metadata`.

This makes it important to order your `types` array thoughtfully. For example, if you have `types = { "source", "pre-compiled" }`, Zoi will default to `pre-compiled` if available, otherwise it will use `source`.

### Building the Package Archive

Once you are confident your package works, you can build a distributable archive. This is what Zoi would download from a pre-built package registry.

```sh
zoi package build --type <build-type> /path/to/your-package.pkg.lua
```

- `--type`: Specify the build type, e.g. `source` or `pre-compiled`. This value is available in your script as the `BUILD_TYPE` global variable.

This command creates a `.pkg.tar.zst` file in the same directory as your `.pkg.lua` file.

### Installing the Built Archive

To ensure your final archive is correct, you can install it locally using the `zoi package install` command.

```sh
zoi package install /path/to/your-package-1.0.0-linux-amd64.pkg.tar.zst
```

This command unpacks the archive and runs the same installation procedure that a user would experience, providing a final end-to-end test of your package.

## Next Steps: Publishing Your Package

Once you have created and tested your package, the next step is to make it available to others. For a detailed guide on how to submit your package to the official Zoidberg repository or how to host your own, see the [Publishing Packages](/docs/zds/zoi/publishing-packages) guide.
